import { Target } from "./Target";
import { Text, TextStyle, Graphics } from "pixi.js";
import {
  AdvertisementManager,
  AdvertisementData,
  AdvertisementContent,
  AdvertisementConfig,
} from "./AdvertisementManager";

export class Advertisement extends Target {
  private advertisementData: AdvertisementData;
  private systemConfig: AdvertisementConfig;
  public adType: string; // L∆∞u lo·∫°i qu·∫£ng c√°o c·ª• th·ªÉ (banner, popup, etc.)

  constructor(adType?: string) {
    const manager = AdvertisementManager.getInstance();

    console.log(`Creating Advertisement with type: ${adType}`);
    console.log(`Manager loaded: ${manager.isDataLoaded()}`);

    // Ensure data is loaded before creating advertisement
    if (!manager.isDataLoaded()) {
      console.error(
        "AdvertisementManager data not loaded, cannot create Advertisement",
      );
      throw new Error(
        "AdvertisementManager data not loaded. Call loadAdvertisementData() first.",
      );
    }

    const data = manager.getAdvertisementConfig(adType);
    const config = manager.getSystemConfig();

    console.log(`Data:`, data);
    console.log(`Config:`, config);

    if (!data) {
      throw new Error(`Failed to get advertisement config for type: ${adType}`);
    }

    if (!config) {
      throw new Error("Failed to get system config");
    }

    // Parse color before calling super()
    const backgroundColor =
      typeof data.backgroundColor === "string"
        ? parseInt(data.backgroundColor.replace("0x", ""), 16)
        : data.backgroundColor;

    super({
      type: adType || "banner", // S·ª≠ d·ª•ng lo·∫°i qu·∫£ng c√°o c·ª• th·ªÉ thay v√¨ "advertisement"
      name: data.name,
      color: backgroundColor,
      size: data.size,
      points: data.points,
      coinValue: data.coinValue,
      ammoReward: data.ammoReward,
      speed: data.speed,
      health: data.health,
      rarity: data.rarity,
      category: "advertisement",
    });

    // Set data after calling super()
    this.adType = adType || "banner";
    this.advertisementData = data;
    this.systemConfig = config;

    // Initialize advertisement after data is set
    this.initializeAdvertisement();

    console.log(
      `Advertisement created successfully with data:`,
      this.advertisementData,
    );
  }

  private initializeAdvertisement(): void {
    console.log("üöÄ Initializing advertisement...");
    this.drawTarget();

    // T·∫°o t√™n lo·∫°i qu·∫£ng c√°o
    this.createAdTypeName();

    // T·∫°o thanh m√°u cho qu·∫£ng c√°o c√≥ nhi·ªÅu m√°u
    if (this.config.health > 1) {
      this.createAdvertisementHealthBar();
    }
  }

  protected setupTarget(): void {
    // Override to prevent Target.setupTarget() from being called
    // We'll call this manually after data is set
    console.log("üéØ Advertisement.setupTarget() called");
  }

  protected drawTarget(): void {
    this.createBackground();
    this.addBannerContent();
  }

  private createBackground(): void {
    console.log("üé® Creating background...");
    console.log("this.advertisementData:", this.advertisementData);

    if (!this.advertisementData) {
      console.error(
        "‚ùå this.advertisementData is undefined in createBackground()",
      );
      return;
    }

    const width = this.config.size * 1.2;
    const height = this.config.size * 0.8;
    const x = -width / 2;
    const y = -height / 2;

    // T·∫°o background ch√≠nh v·ªõi m√†u h√≤a h·ª£p game
    this.targetGraphics.rect(x, y, width, height);
    this.targetGraphics.fill({
      color: this.parseColor(this.advertisementData.backgroundColor),
      alpha: 0.8,
    });

    // T·∫°o shadow effect nh·∫π nh√†ng
    const shadowOffset = 2;
    this.targetGraphics.rect(x + shadowOffset, y + shadowOffset, width, height);
    this.targetGraphics.fill({
      color: 0x000000,
      alpha: 0.1,
    });

    // T·∫°o highlight effect nh·∫π nh√†ng ·ªü tr√™n c√πng
    const highlightHeight = 2;
    const highlightColor = this.getLighterColor(
      this.parseColor(this.advertisementData.backgroundColor),
    );
    this.targetGraphics.rect(x, y, width, highlightHeight);
    this.targetGraphics.fill({
      color: highlightColor,
      alpha: 0.3,
    });
  }

  private getLighterColor(color: number): number {
    // TƒÉng ƒë·ªô s√°ng c·ªßa m√†u ƒë·ªÉ t·∫°o highlight
    const r = Math.min(255, ((color >> 16) & 0xff) + 50);
    const g = Math.min(255, ((color >> 8) & 0xff) + 50);
    const b = Math.min(255, (color & 0xff) + 50);
    return (r << 16) | (g << 8) | b;
  }

  private createAdTypeName(): void {
    console.log("üè∑Ô∏è Creating advertisement type name...");

    const displayName = this.getAdTypeDisplayName();
    const textColor = this.getAdTypeColor();

    const adTypeText = new Text({
      text: displayName,
      style: new TextStyle({
        fontFamily: "Arial",
        fontSize: 10,
        fill: textColor,
        fontWeight: "bold",
        stroke: { color: 0x000000, width: 2 },
        dropShadow: {
          color: 0x000000,
          blur: 2,
          angle: Math.PI / 4,
          distance: 1,
        },
      }),
    });

    adTypeText.anchor.set(0.5);
    adTypeText.x = 0;
    adTypeText.y = -this.config.size * 0.45; // S√°t tr√™n ƒë·∫ßu qu·∫£ng c√°o

    this.addChild(adTypeText);
    console.log(
      `‚úÖ Advertisement type name "${displayName}" created successfully`,
    );
  }

  private getAdTypeDisplayName(): string {
    const displayNames: { [key: string]: string } = {
      banner: "BANNER",
      popup: "POPUP",
      video: "VIDEO",
      iphone_repair: "IPHONE",
      ipad_repair: "IPAD",
      android_repair: "ANDROID",
      unlock_service: "UNLOCK",
      frp_remove: "FRP",
      knox_check: "KNOX",
      camera_install: "CAMERA",
      camera_3k: "CAM 3K",
      solar_light: "SOLAR",
      solar_24h: "SOLAR 24H",
      wifi_install: "WIFI",
      server_install: "SERVER",
      nghiaapple_mega: "MEGA",
      nghiaapple_viral: "VIRAL",
      tech_solution: "TECH",
      camera_full_hd: "CAM HD",
      solar_premium: "SOLAR PRO",
      software_service: "SOFTWARE",
      repair_comprehensive: "REPAIR",
      contact_comprehensive: "CONTACT",
    };

    return displayNames[this.adType] || this.adType.toUpperCase();
  }

  private getAdTypeColor(): number {
    const colors: { [key: string]: number } = {
      banner: 0x3498db, // Xanh d∆∞∆°ng
      popup: 0xe74c3c, // ƒê·ªè
      video: 0x9b59b6, // T√≠m
      iphone_repair: 0x2ecc71, // Xanh l√°
      ipad_repair: 0x2ecc71, // Xanh l√°
      android_repair: 0x2ecc71, // Xanh l√°
      unlock_service: 0xf39c12, // Cam
      frp_remove: 0xf39c12, // Cam
      knox_check: 0xf39c12, // Cam
      camera_install: 0x1abc9c, // Xanh ng·ªçc
      camera_3k: 0x1abc9c, // Xanh ng·ªçc
      solar_light: 0xf1c40f, // V√†ng
      solar_24h: 0xf1c40f, // V√†ng
      wifi_install: 0x34495e, // X√°m ƒë·∫≠m
      server_install: 0x34495e, // X√°m ƒë·∫≠m
      nghiaapple_mega: 0xe67e22, // Cam ƒë·∫≠m
      nghiaapple_viral: 0xe67e22, // Cam ƒë·∫≠m
      tech_solution: 0x8e44ad, // T√≠m ƒë·∫≠m
      camera_full_hd: 0x1abc9c, // Xanh ng·ªçc
      solar_premium: 0xf1c40f, // V√†ng
      software_service: 0x8e44ad, // T√≠m ƒë·∫≠m
      repair_comprehensive: 0x2ecc71, // Xanh l√°
      contact_comprehensive: 0x3498db, // Xanh d∆∞∆°ng
    };

    return colors[this.adType] || 0xffffff; // M·∫∑c ƒë·ªãnh tr·∫Øng
  }

  private createAdvertisementHealthBar(): void {
    console.log("‚ù§Ô∏è Creating advertisement health bar...");
    console.log("Health:", this.config.health);

    // S·ª≠ d·ª•ng h·ªá th·ªëng thanh m√°u c·ªßa Target
    this.healthBar = new Graphics();
    this.addChild(this.healthBar);
    this.updateHealthBar();

    console.log("‚úÖ Advertisement health bar created successfully");
  }

  protected updateHealthBar(): void {
    if (!this.healthBar) return;

    console.log("üîÑ Updating advertisement health bar...");
    console.log("Current health:", this.currentHealth);
    console.log("Max health:", this.maxHealth);

    this.healthBar.clear();

    const barWidth = this.config.size * 1.2; // Chi·ªÅu r·ªông b·∫±ng v·ªõi qu·∫£ng c√°o
    const barHeight = 8;
    const barX = -barWidth / 2;
    const barY = -this.config.size * 0.4; // S√°t tr√™n ƒë·∫ßu qu·∫£ng c√°o, ngay d∆∞·ªõi t√™n lo·∫°i

    console.log("Health bar dimensions:", { barWidth, barHeight, barX, barY });

    // Background
    this.healthBar.rect(barX, barY, barWidth, barHeight);
    this.healthBar.fill({ color: 0x333333, alpha: 0.8 });

    // Health bar - s·ª≠ d·ª•ng currentHealth th·ª±c t·∫ø
    const healthPercentage = this.currentHealth / this.maxHealth;
    const healthWidth = barWidth * healthPercentage;
    const healthColor = this.getHealthBarColor(healthPercentage);

    this.healthBar.rect(barX, barY, healthWidth, barHeight);
    this.healthBar.fill({ color: healthColor, alpha: 0.9 });

    console.log("‚úÖ Health bar updated successfully");
  }

  protected getHealthBarColor(percentage: number): number {
    if (percentage > 0.6) return 0x27ae60; // Xanh l√°
    if (percentage > 0.3) return 0xf39c12; // Cam
    return 0xe74c3c; // ƒê·ªè
  }

  private addBannerContent(): void {
    console.log("üéØ Adding banner content...");
    console.log("Advertisement data:", this.advertisementData);
    console.log("System config:", this.systemConfig);

    if (!this.advertisementData || !this.systemConfig) {
      console.error("Advertisement data or system config is undefined");
      return;
    }

    const content = this.advertisementData.content;
    const layoutConfig = this.systemConfig.layout;

    console.log("Content to render:", content);
    console.log("Layout config to use:", layoutConfig);

    // S·ª≠ d·ª•ng layout chung cho t·∫•t c·∫£ qu·∫£ng c√°o
    this.addSimpleContent(content, layoutConfig);
  }

  private createText(
    text: string,
    x: number,
    y: number,
    fontSize: number,
    color: number = 0xffffff,
  ): Text {
    console.log(
      `üìù Creating text: "${text}" at (${x}, ${y}) with size ${fontSize} and color ${color}`,
    );

    const style = new TextStyle({
      fontFamily: "Arial",
      fontSize: fontSize,
      fill: color,
      align: "center",
      fontWeight: "bold",
    });

    const textObj = new Text({ text, style });
    textObj.x = x;
    textObj.y = y;
    textObj.anchor.set(0.5);

    this.addChild(textObj);
    console.log(`‚úÖ Text "${text}" added successfully`);
    return textObj;
  }

  // Layout handler s·ª≠ d·ª•ng layout chung
  private addSimpleContent(
    content: AdvertisementContent,
    layoutConfig: any,
  ): void {
    console.log("üé® Adding simple content...");
    console.log("Content:", content);
    console.log("Layout config:", layoutConfig);
    console.log("This.config:", this.config);
    console.log("This.config.size:", this.config?.size);

    const fontSize = Math.max(8, this.config.size * 0.08);
    const textColor = this.parseColor(this.advertisementData.textColor);

    // Icon
    if (content.icon && layoutConfig.icon) {
      this.createText(
        content.icon,
        this.config.size * layoutConfig.icon.position.x,
        this.config.size * layoutConfig.icon.position.y,
        fontSize * layoutConfig.icon.size,
        textColor,
      );
    }

    // Title
    if (content.title && layoutConfig.title) {
      this.createText(
        content.title,
        this.config.size * layoutConfig.title.position.x,
        this.config.size * layoutConfig.title.position.y,
        fontSize * layoutConfig.title.size,
        textColor,
      );
    }

    // Sub Title
    if (content.sub_title && layoutConfig.sub_title) {
      this.createText(
        content.sub_title,
        this.config.size * layoutConfig.sub_title.position.x,
        this.config.size * layoutConfig.sub_title.position.y,
        fontSize * layoutConfig.sub_title.size,
        textColor,
      );
    }

    // Lines
    if (content.lines && layoutConfig.lines) {
      content.lines.forEach((line, index) => {
        const lineY =
          layoutConfig.lines.position.y + index * layoutConfig.lines.spacing;
        this.createText(
          line,
          this.config.size * layoutConfig.lines.position.x,
          this.config.size * lineY,
          fontSize * layoutConfig.lines.size,
          textColor,
        );
      });
    }
  }

  private parseColor(color: string | number): number {
    console.log(`üé® Parsing color: ${color} (type: ${typeof color})`);

    if (typeof color === "string") {
      const parsed = parseInt(color, 16);
      console.log(`üé® Parsed color: ${parsed}`);
      return parsed;
    }

    console.log(`üé® Using color as number: ${color}`);
    return color;
  }
}
